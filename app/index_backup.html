<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChordChart Pro v2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chord-output, .lyric-output, .summary-chord { font-family: 'Roboto Mono', monospace; line-height: 1.6; white-space: pre; }
        .chord-output, .summary-chord { font-weight: 700; }
        #outputArea { 
            transition: column-count 0.3s ease-in-out; 
            max-height: 60vh; 
            overflow-y: auto; 
            padding: 1rem;
        }
        .output-container.two-columns { 
            /* Usar layout de tabela para melhor consistência com a impressão */
            display: table !important;
            width: 100% !important;
            table-layout: fixed !important;
            border-collapse: separate !important;
            border-spacing: 1rem 0 !important;
        }
        .column-container {
            /* Cada coluna ocupa metade do espaço disponível */
            display: table-cell !important;
            width: 50% !important;
            vertical-align: top !important;
            /* Remover padding-right pois já temos border-spacing na tabela */
        }
        /* Garantir que as seções não quebrem entre colunas na tela */
        .section-container { 
            break-inside: avoid !important; 
            page-break-inside: avoid !important;
            margin-bottom: 1rem !important;
            display: block !important;
        }
        
        /* Na impressão, permitir quebras para economizar páginas */
        @media print {
            /* Configurações para impressão de seções */
            .section-container { 
                /* Permitir quebra de seção entre páginas/colunas */
                break-inside: auto !important; 
                page-break-inside: auto !important;
                /* Adicionar margem para melhorar a separação visual */
                margin-bottom: 1.5rem !important;
                display: block !important;
            }
            /* Permitir quebra após a seção se necessário */
            .section-container:not(:last-child) {
                break-after: auto !important;
                page-break-after: auto !important;
            }
            
            /* Forçar que cada coluna comece em uma nova página se necessário */
            .column-container:first-child {
                break-after: avoid !important;
                page-break-after: avoid !important;
                /* Garantir que a primeira coluna não quebre entre páginas */
                break-inside: avoid !important;
                page-break-inside: avoid !important;
                /* Definir altura máxima para a primeira coluna */
                max-height: 100vh !important;
                overflow: hidden !important;
            }
            .column-container:last-child {
                /* Permitir que a segunda coluna continue na mesma página se houver espaço */
                /* break-before: page !important; */
                /* page-break-before: always !important; */
            }
        }
        .section-container h3 {
            margin-bottom: 0.5rem !important;
        }
        #view-wrapper { transition: all 0.3s ease-in-out; border: 1px solid #e5e7eb; margin: auto; }
        .view-tablet { width: 768px; }
        .view-mobile { width: 425px; }
        dialog::backdrop { background: rgba(0, 0, 0, 0.5); }
        .hidden { display: none; }
        .sortable-ghost { opacity: 0.4; background-color: #c7d2fe; }
        .handle { cursor: move; }

        /* Animação para o botão tela cheia */
        @keyframes fadeInScale {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        #fullscreen-btn {
            animation: fadeInScale 0.3s ease-out;
        }

        /* Animações para a página de login */
        @keyframes fadeInUp {
            0% { opacity: 0; transform: translateY(30px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #login-container .bg-white\/80 {
            animation: fadeInUp 0.6s ease-out;
        }

        #login-container .bg-gradient-to-br {
            animation: float 6s ease-in-out infinite;
        }

        #login-container .bg-gradient-to-br:nth-child(2) {
            animation-delay: -3s;
        }

        /* Efeito de hover nos inputs */
        #login-container input:focus {
            transform: scale(1.02);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Efeito de placeholder */
        #login-container input::placeholder {
            color: #9CA3AF;
            transition: color 0.2s ease;
        }

        #login-container input:focus::placeholder {
            color: #6B7280;
        }

        /* Efeito para o botão de toggle de senha */
        .toggle-password-btn {
            transition: all 0.2s ease;
        }

        .toggle-password-btn:hover {
            background-color: rgba(59, 130, 246, 0.1);
            border-radius: 0.5rem;
        }

        .toggle-password-btn:active {
            transform: scale(0.95);
        }

        /* Efeito de loading no botão */
        .btn-loading {
            position: relative;
            pointer-events: none;
        }

        .btn-loading::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            top: 50%;
            left: 50%;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid transparent;
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* NOVA E SIMPLIFICADA ABORDAGEM PARA TELA CHEIA */
        #view-wrapper:fullscreen {
            overflow-y: auto !important;
            background-color: white;
            padding: 2rem; /* Adiciona um respiro dentro da tela cheia */
        }

        @media print { 
            .no-print { display: none !important; } 
            body { background-color: white !important; margin: 0; padding: 0; } 
            main { padding: 0 !important; } 
            #view-wrapper { width: 100% !important; border: none !important; box-shadow: none !important; padding: 1cm !important; } 
            #outputArea { 
                padding: 0 !important; 
                box-shadow: none !important; 
                border: none !important; 
                max-height: none !important;
                overflow: visible !important;
                position: relative !important;
            } 
            /* Garante que o cabeçalho apareça em cada página ao imprimir */
            #outputArea > div:first-child {
                position: running(header) !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                z-index: 1000 !important;
                margin-bottom: 0.5cm !important;
                print-color-adjust: exact !important;
                -webkit-print-color-adjust: exact !important;
                background-color: white !important;
                page-break-after: avoid !important;
                page-break-inside: avoid !important;
            } 
            /* Adiciona espaço para o cabeçalho em cada página */
            .chord-content-container {
                margin-top: 1cm !important;
            }
            /* Garante que o cabeçalho apareça em cada página */
            @page {
                margin-top: 2cm !important;
                @top-center {
                    content: element(header);
                }
            } 
            .output-container.two-columns { 
                /* Usar layout de tabela para melhor controle de impressão */
                display: table !important;
                width: 100% !important;
                table-layout: fixed !important;
                border-collapse: separate !important;
                border-spacing: 1rem 0 !important;
                /* Evitar quebras de página dentro do container */
                break-inside: avoid-page !important;
                page-break-inside: avoid !important;
                /* Forçar que o container comece em uma nova página se necessário */
                break-before: page !important;
                page-break-before: always !important;
            }
            .column-container {
                /* Cada coluna ocupa metade do espaço disponível */
                display: table-cell !important;
                width: 50% !important;
                vertical-align: top !important;
                /* Garantir que cada coluna seja tratada como uma unidade indivisível */
                break-inside: avoid !important;
                page-break-inside: avoid !important;
                /* Forçar que a coluna permaneça na mesma página */
                break-before: avoid !important;
                page-break-before: avoid !important;
            } 
            h2, h3 { color: black !important; } 
            .chord-output, .summary-chord { color: #1e40af !important; } 
            .lyric-output { color: #111827 !important; } 
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="login-container" class="flex items-center justify-center min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50">
        <div class="w-full max-w-md">
            <!-- Card principal -->
            <div class="bg-white/80 backdrop-blur-sm rounded-2xl shadow-2xl border border-white/20 p-8">
                <!-- Header com logo -->
                <div class="text-center mb-8">
                    <div class="inline-flex items-center justify-center w-16 h-16 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full mb-4 shadow-lg">
                        <i class="fas fa-music text-white text-2xl"></i>
                    </div>
                    <h1 class="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                        ChordChart Pro
                    </h1>
                    <p class="text-gray-600 mt-2 text-sm">Sua ferramenta de cifras avançada</p>
                </div>

                <!-- Formulário de login -->
                <form id="login-form" class="space-y-6" method="post" action="javascript:void(0);">
                    <div class="space-y-4">
                        <!-- Campo usuário -->
                        <div class="relative">
                            <label for="username" class="block text-sm font-medium text-gray-700 mb-2">
                                <i class="fas fa-user mr-2 text-blue-500"></i>Usuário
                            </label>
                            <div class="relative">
                                <input 
                                    id="username" 
                                    name="username" 
                                    type="text" 
                                    required 
                                    class="w-full px-4 py-3 border border-gray-300 rounded-xl shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 bg-white/50 backdrop-blur-sm"
                                    placeholder="Digite seu usuário"
                                >
                                <div class="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                                    <i class="fas fa-user text-gray-400"></i>
                                </div>
                            </div>
                        </div>

                        <!-- Campo senha -->
                        <div class="relative">
                            <label for="password" class="block text-sm font-medium text-gray-700 mb-2">
                                <i class="fas fa-lock mr-2 text-blue-500"></i>Senha
                            </label>
                            <div class="relative">
                                <input 
                                    id="password" 
                                    name="password" 
                                    type="password" 
                                    required 
                                    class="w-full px-4 py-3 border border-gray-300 rounded-xl shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 bg-white/50 backdrop-blur-sm"
                                    placeholder="Digite sua senha"
                                    autocomplete="current-password"
                                >
                                <button
                                    type="button"
                                    class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-400 hover:text-gray-600 toggle-password-btn transition-colors duration-200"
                                    title="Mostrar senha"
                                >
                                    <i class="fas fa-eye"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Mensagem de erro -->
                    <div id="login-error" class="hidden">
                        <div class="flex items-center p-3 bg-red-50 border border-red-200 rounded-xl">
                            <i class="fas fa-exclamation-circle text-red-500 mr-3"></i>
                            <p class="text-sm text-red-600">Usuário ou senha inválidos.</p>
                        </div>
                    </div>

                    <!-- Botão de login -->
                    <button 
                        type="submit" 
                        class="w-full px-6 py-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 focus:ring-4 focus:ring-blue-300"
                    >
                        <i class="fas fa-sign-in-alt mr-2"></i>
                        Entrar
                    </button>
                </form>

                <!-- Footer -->
                <div class="mt-8 text-center">
                    <p class="text-xs text-gray-500">
                        <i class="fas fa-shield-alt mr-1"></i>
                        Conexão segura via HTTPS
                    </p>
                </div>
            </div>

            <!-- Decoração de fundo -->
            <div class="absolute inset-0 -z-10 overflow-hidden">
                <div class="absolute -top-40 -right-40 w-80 h-80 bg-gradient-to-br from-blue-400/20 to-purple-400/20 rounded-full blur-3xl"></div>
                <div class="absolute -bottom-40 -left-40 w-80 h-80 bg-gradient-to-br from-purple-400/20 to-pink-400/20 rounded-full blur-3xl"></div>
            </div>
        </div>
    </div>

    <div id="app-container" class="hidden flex-col lg:flex-row min-h-screen">
        <aside class="w-full lg:w-96 bg-white p-6 shadow-lg lg:h-screen lg:sticky lg:top-0 overflow-y-auto no-print">
            <div class="flex justify-between items-center"><h1 class="text-2xl font-bold text-blue-700">ChordChart Pro</h1><div class="flex items-center"><span id="welcome-user" class="text-sm text-gray-600 mr-2"></span><button id="manage-users-btn" class="p-1 text-gray-500 hover:text-blue-600 hidden" title="Gerenciar Usuários"><i class="fas fa-users-cog"></i></button><button id="change-password-btn" class="p-1 text-gray-500 hover:text-blue-600" title="Alterar Senha"><i class="fas fa-key"></i></button><button id="logout-btn" class="p-1 text-gray-500 hover:text-red-600" title="Sair"><i class="fas fa-sign-out-alt"></i></button></div></div>
            <p class="text-sm text-gray-500 mb-4">Sua ferramenta de cifras avançada.</p>
            <div class="mb-4"><label for="songInput" class="block text-sm font-medium text-gray-700 mb-1">Cifra Atual:</label><textarea id="songInput" rows="8" class="w-full p-2 border border-gray-300 rounded-md shadow-sm text-sm" placeholder="[Intro]&#10;G D Em C&#10;..."></textarea>
                <div class="flex gap-2 mt-2">
                    <button id="generateButton" class="flex-grow bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-sm">Gerar</button>
                    <button id="saveButton" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-md shadow-sm">Salvar</button>
                    <button id="saveAsButton" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md shadow-sm">Salvar Como</button>
                    <button id="clearButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md shadow-sm">Limpar</button>
                </div>
            </div>
            <div class="flex flex-col gap-2 mb-4">
                <button id="open-songs-btn" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-md shadow-sm">Abrir Músicas Salvas</button>
                <button id="open-setlists-btn" class="w-full bg-indigo-700 hover:bg-indigo-800 text-white font-bold py-2 px-4 rounded-md shadow-sm">Gerenciar Setlists</button>
            </div>
            <div class="space-y-6">
                 <div><h3 class="font-semibold text-gray-800 mb-2">Tom da Música</h3><div class="flex items-center justify-center gap-4 bg-gray-50 p-3 rounded-md"><button id="transpose-down" class="px-3 py-1 bg-gray-300 rounded-md text-lg font-bold">-</button><div class="text-center"><span id="transpose-status" class="font-bold text-lg text-blue-600">Original</span></div><button id="transpose-up" class="px-3 py-1 bg-gray-300 rounded-md text-lg font-bold">+</button></div></div>
                 <div><h3 class="font-semibold text-gray-800 mb-2">Capô</h3><div class="bg-gray-50 p-3 rounded-md"><div class="flex items-center justify-between mb-2"><label for="capo-position" class="text-sm">Posição do Capô:</label><span id="capo-status" class="text-sm font-medium text-blue-600">0</span></div><input id="capo-position" type="range" min="0" max="12" value="0" class="w-full mb-2"><div id="capo-info" class="text-xs text-gray-600 text-center">Sem capô</div></div></div>
                 <div><h3 class="font-semibold text-gray-800 mb-2">Formatação da Cifra</h3><div class="space-y-3 bg-gray-50 p-3 rounded-md"><div class="flex items-center justify-between"><label for="lyrics-size" class="text-sm">Letra:</label><input id="lyrics-size" type="range" min="10" max="32" value="16" class="w-2/3"><input id="lyrics-color" type="color" value="#374151" class="w-8 h-8 p-0 border-none rounded"></div><div class="flex items-center justify-between"><label for="chords-size" class="text-sm">Acordes:</label><input id="chords-size" type="range" min="10" max="32" value="16" class="w-2/3"><input id="chords-color" type="color" value="#2563eb" class="w-8 h-8 p-0 border-none rounded"></div></div></div>
                 <div><h3 class="font-semibold text-gray-800 mb-2">Layout e Visualização</h3><div class="grid grid-cols-2 gap-2 bg-gray-50 p-3 rounded-md"><button id="view-mode-toggle" class="bg-gray-200 py-2 rounded-md text-sm">Ver Mapa</button><button id="columns-toggle" class="bg-gray-200 py-2 rounded-md text-sm">Usar 2 Colunas</button><button id="print-button" class="col-span-2 bg-green-600 text-white hover:bg-green-700 py-2 rounded-md text-sm">Imprimir / Salvar PDF</button></div><div class="flex justify-center gap-2 mt-2 bg-gray-50 p-3 rounded-md"><button data-view="desktop" class="view-toggle-btn p-2 text-gray-500 hover:text-blue-600" title="Desktop"><i class="fas fa-desktop"></i></button><button data-view="tablet" class="view-toggle-btn p-2 text-gray-500 hover:text-blue-600" title="Tablet"><i class="fas fa-tablet-alt"></i></button><button data-view="mobile" class="view-toggle-btn p-2 text-gray-500 hover:text-blue-600" title="Mobile"><i class="fas fa-mobile-alt"></i></button></div></div>
                 <div><h3 class="font-semibold text-gray-800 mb-2">Rolagem Automática</h3><div class="bg-gray-50 p-3 rounded-md"><div class="flex items-center justify-between mb-2"><button id="scroll-toggle" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md text-sm"><i class="fas fa-play mr-1"></i>Iniciar Rolagem</button><span id="scroll-status" class="text-sm text-gray-600">Parado</span></div><div class="space-y-3"><div class="flex items-center justify-between"><label for="scroll-speed" class="text-sm">Velocidade:</label><span id="speed-display" class="text-sm font-medium text-blue-600">1x</span></div><input id="scroll-speed" type="range" min="0.5" max="3" step="0.1" value="1" class="w-full mb-2"><div class="flex items-center justify-between"><label for="manual-speed" class="text-sm">Velocidade Manual:</label><input type="number" id="manual-speed" min="0.01" max="5" step="0.01" value="1" class="w-16 p-1 border rounded text-sm"></div><div class="text-xs text-gray-500">Velocidade baseada no BPM da música</div></div></div></div>
            </div>
        </aside>
        <main class="flex-1 p-4 sm:p-8 bg-gray-100">
            <div id="view-wrapper" class="bg-white p-8 rounded-lg shadow-inner min-h-full">
                <div id="outputArea" class="output-container"></div>
                <div id="summaryArea" class="mt-8"></div>
                <div id="uniqueChordsArea" class="mt-8"></div>
            </div>
        </main>

    <style>
        /* Quando no modo chart (não mapa), aumentar o espaço para a cifra */
        #outputArea {
            transition: max-height 0.3s ease-in-out;
        }
        /* Quando uniqueChordsArea está vazio, aumentar o espaço do outputArea */
        #uniqueChordsArea:empty + #outputArea,
        #uniqueChordsArea:empty ~ #outputArea {
            max-height: 80vh !important;
        }
        /* Quando no modo chart, o outputArea deve ocupar mais espaço */
        body:not([data-view="map"]) #outputArea {
            max-height: 80vh !important;
        }
    </style>
    </div>

    <!-- Botão flutuante de tela cheia -->
    <button id="fullscreen-btn" class="fixed bottom-6 right-6 z-50 bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-full shadow-lg transition-all duration-300 hover:scale-110 no-print" title="Tela Cheia">
        <i class="fas fa-expand text-lg"></i>
    </button>

    <dialog id="save-modal" class="p-6 rounded-lg shadow-xl border w-full max-w-md"><h3 class="text-lg font-bold mb-4">Salvar Música</h3><form id="save-form"><div class="space-y-4"><label for="song-title-input" class="block text-sm mb-1">Título da Música:</label><input type="text" id="song-title-input" class="w-full p-2 border rounded-md" required><label for="original-key-input" class="block text-sm mb-1">Tom Original:</label><input type="text" id="original-key-input" class="w-full p-2 border rounded-md" placeholder="Ex: G, Am, C#m"><div class="grid grid-cols-2 gap-4"><div><label for="song-duration" class="block text-sm mb-1">Duração (min:seg):</label><input type="text" id="song-duration" class="w-full p-2 border rounded-md" placeholder="3:45" pattern="[0-9]+:[0-5][0-9]"><div class="text-xs text-gray-500 mt-1">Formato: MM:SS</div></div><div><label for="song-bpm" class="block text-sm mb-1">BPM:</label><input type="number" id="song-bpm" min="40" max="200" class="w-full p-2 border rounded-md" placeholder="120"><div class="text-xs text-gray-500 mt-1">40-200 BPM</div></div></div><label for="save-capo-position" class="block text-sm mb-1">Posição do Capô:</label><input type="number" id="save-capo-position" min="0" max="12" value="0" class="w-full p-2 border rounded-md" placeholder="0"><div class="flex items-center mt-2"><input id="is-public-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"><label for="is-public-checkbox" class="ml-2 block text-sm text-gray-900">Compartilhar com todos os usuários</label></div></div><div class="flex justify-end gap-4 mt-6"><button type="button" class="cancel-btn py-2 px-4 bg-gray-200 rounded-md">Cancelar</button><button type="submit" class="py-2 px-4 bg-blue-600 text-white rounded-md">Salvar</button></div></form></dialog>
    <dialog id="songs-modal" class="p-6 rounded-lg shadow-xl border w-full max-w-lg"><div class="flex justify-between items-center mb-4"><h3 class="text-lg font-bold">Músicas Salvas</h3><button class="cancel-btn text-2xl font-light">&times;</button></div><div class="border-b border-gray-200 mb-2"><nav class="-mb-px flex gap-4" aria-label="Tabs"><button id="my-songs-tab" class="tab-btn active whitespace-nowrap border-b-2 py-2 px-1 text-sm font-medium">Minhas Músicas</button><button id="public-songs-tab" class="tab-btn whitespace-nowrap border-b-2 border-transparent py-2 px-1 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700">Todas as Músicas</button></nav></div><div id="modal-songs-list" class="bg-gray-50 p-2 rounded-md h-96 overflow-y-auto border"></div></dialog>
    <dialog id="user-management-modal" class="p-6 rounded-lg shadow-xl border w-full max-w-lg"><div class="flex justify-between items-center mb-4"><h3 class="text-lg font-bold">Gerenciar Usuários</h3><button id="open-create-user-modal-btn" class="bg-blue-500 text-white px-3 py-1 rounded text-sm hover:bg-blue-600">Criar Novo</button></div><div id="modal-users-list" class="bg-gray-50 p-2 rounded-md h-80 overflow-y-auto border"></div><div class="flex justify-end mt-4"><button type="button" class="cancel-btn py-2 px-4 bg-gray-200 rounded-md">Fechar</button></div></dialog>
    <dialog id="change-password-modal" class="p-6 rounded-lg shadow-xl border w-full max-w-md"><h3 class="text-lg font-bold mb-4">Alterar Senha</h3><form id="change-password-form"><div class="space-y-4"><div><label for="old-password" class="block text-sm mb-1">Senha Antiga:</label><div class="relative"><input type="password" id="old-password" class="w-full p-2 border rounded-md" required><button type="button" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-400 hover:text-gray-600 toggle-password-btn"><i class="fas fa-eye"></i></button></div></div><div><label for="new-password" class="block text-sm mb-1">Nova Senha:</label><div class="relative"><input type="password" id="new-password" class="w-full p-2 border rounded-md" required><button type="button" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-400 hover:text-gray-600 toggle-password-btn"><i class="fas fa-eye"></i></button></div></div></div><p id="change-password-feedback" class="text-sm mt-4 hidden"></p><div class="flex justify-end gap-4 mt-6"><button type="button" class="cancel-btn py-2 px-4 bg-gray-200 rounded-md">Cancelar</button><button type="submit" class="py-2 px-4 bg-blue-600 text-white rounded-md">Alterar Senha</button></div></form></dialog>
    <dialog id="create-user-modal" class="p-6 rounded-lg shadow-xl border w-full max-w-md"><h3 class="text-lg font-bold mb-4">Criar Novo Usuário</h3><form id="create-user-form"><div class="space-y-4"><div><label for="new-username" class="block text-sm mb-1">Nome de Usuário:</label><input type="text" id="new-username" class="w-full p-2 border rounded-md" required></div><div><label for="create-user-password" class="block text-sm mb-1">Senha:</label><div class="relative"><input type="password" id="create-user-password" class="w-full p-2 border rounded-md" required><button type="button" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-400 hover:text-gray-600 toggle-password-btn"><i class="fas fa-eye"></i></button></div></div></div><p id="create-user-feedback" class="text-sm mt-4 hidden"></p><div class="flex justify-end gap-4 mt-6"><button type="button" class="cancel-btn py-2 px-4 bg-gray-200 rounded-md">Cancelar</button><button type="submit" class="py-2 px-4 bg-blue-600 text-white rounded-md">Criar Usuário</button></div></form></dialog>
    <dialog id="setlists-modal" class="p-6 rounded-lg shadow-xl border w-full max-w-xl">
        <div class="flex justify-between items-center mb-4">
            <h3 id="setlists-modal-title" class="text-lg font-bold">Gerenciar Setlists</h3>
            <button class="cancel-btn text-2xl font-light">&times;</button>
        </div>
        <div id="setlists-view-container">
            <nav id="setlists-tabs-nav" class="-mb-px flex gap-4 border-b border-gray-200" aria-label="Tabs">
                <button id="my-setlists-tab" class="tab-btn active whitespace-nowrap border-b-2 py-2 px-1 text-sm font-medium">Meus Setlists</button>
                <button id="public-setlists-tab" class="tab-btn whitespace-nowrap border-b-2 border-transparent py-2 px-1 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700">Setlists Públicos</button>
            </nav>
        </div>
        <div id="modal-setlists-list" class="bg-gray-50 p-2 rounded-md h-80 overflow-y-auto border-x border-b mb-4"></div>
        <form id="create-setlist-form" class="p-4 border-t">
            <h4 class="font-semibold mb-2">Criar Novo Setlist</h4>
            <div class="flex items-end gap-3">
                <div class="flex-grow">
                    <label for="setlist-name-input" class="block text-sm mb-1">Nome do Setlist:</label>
                    <input type="text" id="setlist-name-input" class="w-full p-2 border rounded-md" required>
                </div>
                <div class="flex items-center pb-2">
                    <input id="setlist-is-public-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="setlist-is-public-checkbox" class="ml-2 block text-sm text-gray-900">Público</label>
                </div>
                <button type="submit" class="py-2 px-4 bg-indigo-600 text-white rounded-md h-fit">Criar</button>
            </div>
            <p id="create-setlist-feedback" class="text-sm mt-2 hidden"></p>
        </form>
    </dialog>
    <dialog id="add-to-setlist-modal" class="p-6 rounded-lg shadow-xl border w-full max-w-sm">
        <form id="add-to-setlist-form">
            <h3 class="text-lg font-bold mb-4">Adicionar Música ao Setlist</h3>
            <div class="space-y-4">
                <label for="setlist-select" class="block text-sm mb-1">Escolha o setlist:</label>
                <select id="setlist-select" class="w-full p-2 border rounded-md"></select>
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button type="button" class="cancel-btn py-2 px-4 bg-gray-200 rounded-md">Cancelar</button>
                <button type="submit" class="py-2 px-4 bg-blue-600 text-white rounded-md">Adicionar</button>
            </div>
        </form>
    </dialog>

    <dialog id="add-songs-to-setlist-modal" class="p-6 rounded-lg shadow-xl border w-full max-w-lg">
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-lg font-bold">Adicionar Músicas ao Setlist</h3>
            <button class="cancel-btn text-2xl font-light">&times;</button>
        </div>
        <div id="available-songs-list" class="bg-gray-50 p-2 rounded-md h-80 overflow-y-auto border mb-4">
            <p class="text-center text-gray-400 text-sm p-4">Carregando músicas disponíveis...</p>
        </div>
        <div class="flex justify-end gap-4">
            <button type="button" class="cancel-btn py-2 px-4 bg-gray-200 rounded-md">Fechar</button>
        </div>
    </dialog>

    <script>
    // --- STATE & DOM ---
    const state = { 
        songStructure: [], 
        transposeAmount: 0, 
        currentView: 'chart', 
        isTwoColumns: false, 
        capoPosition: 0,
        isScrolling: false,
        scrollInterval: null,
        currentSongData: null,
        currentScrollStep: 2,
        currentSongId: null
    };
    const dom = { 
        songInput: document.getElementById('songInput'), generateButton: document.getElementById('generateButton'), saveButton: document.getElementById('saveButton'), saveAsButton: document.getElementById('saveAsButton'), clearButton: document.getElementById('clearButton'), outputArea: document.getElementById('outputArea'), summaryArea: document.getElementById('summaryArea'), uniqueChordsArea: document.getElementById('uniqueChordsArea'),
        fullscreenBtn: document.getElementById('fullscreen-btn'), appContainer: document.getElementById('app-container'), transposeStatus: document.getElementById('transpose-status'), loginContainer: document.getElementById('login-container'), loginForm: document.getElementById('login-form'), loginError: document.getElementById('login-error'), welcomeUser: document.getElementById('welcome-user'), logoutBtn: document.getElementById('logout-btn'),
        transposeUpBtn: document.getElementById('transpose-up'), transposeDownBtn: document.getElementById('transpose-down'), capoPosition: document.getElementById('capo-position'), capoStatus: document.getElementById('capo-status'), capoInfo: document.getElementById('capo-info'), lyricsSizeSlider: document.getElementById('lyrics-size'), chordsSizeSlider: document.getElementById('chords-size'), lyricsColorPicker: document.getElementById('lyrics-color'), chordsColorPicker: document.getElementById('chords-color'),
        viewModeToggle: document.getElementById('view-mode-toggle'), columnsToggle: document.getElementById('columns-toggle'), viewWrapper: document.getElementById('view-wrapper'), 
        saveModal: document.getElementById('save-modal'), saveForm: document.getElementById('save-form'), songTitleInput: document.getElementById('song-title-input'), originalKeyInput: document.getElementById('original-key-input'), songDuration: document.getElementById('song-duration'), songBpm: document.getElementById('song-bpm'), saveCapoPosition: document.getElementById('save-capo-position'), isPublicCheckbox: document.getElementById('is-public-checkbox'),
        openSongsBtn: document.getElementById('open-songs-btn'), songsModal: document.getElementById('songs-modal'), modalSongsList: document.getElementById('modal-songs-list'), mySongsTab: document.getElementById('my-songs-tab'), publicSongsTab: document.getElementById('public-songs-tab'), 
        manageUsersBtn: document.getElementById('manage-users-btn'), userManagementModal: document.getElementById('user-management-modal'), modalUsersList: document.getElementById('modal-users-list'), openCreateUserModalBtn: document.getElementById('open-create-user-modal-btn'), createUserModal: document.getElementById('create-user-modal'), createUserForm: document.getElementById('create-user-form'), createUserFeedback: document.getElementById('create-user-feedback'), 
        changePasswordBtn: document.getElementById('change-password-btn'), changePasswordModal: document.getElementById('change-password-modal'), changePasswordForm: document.getElementById('change-password-form'), changePasswordFeedback: document.getElementById('change-password-feedback'),
        openSetlistsBtn: document.getElementById('open-setlists-btn'), setlistsModal: document.getElementById('setlists-modal'), setlistsModalTitle: document.getElementById('setlists-modal-title'), setlistsTabsNav: document.getElementById('setlists-tabs-nav'), modalSetlistsList: document.getElementById('modal-setlists-list'), mySetlistsTab: document.getElementById('my-setlists-tab'), publicSetlistsTab: document.getElementById('public-setlists-tab'), createSetlistForm: document.getElementById('create-setlist-form'), createSetlistFeedback: document.getElementById('create-setlist-feedback'), setlistsViewContainer: document.getElementById('setlists-view-container'),
        addToSetlistModal: document.getElementById('add-to-setlist-modal'), 
        addToSetlistForm: document.getElementById('add-to-setlist-form'), 
        setlistSelect: document.getElementById('setlist-select'),
        addSongsToSetlistModal: document.getElementById('add-songs-to-setlist-modal'),
        availableSongsList: document.getElementById('available-songs-list'),
        scrollToggle: document.getElementById('scroll-toggle'), scrollStatus: document.getElementById('scroll-status'), scrollSpeed: document.getElementById('scroll-speed'), speedDisplay: document.getElementById('speed-display'), manualSpeed: document.getElementById('manual-speed')
    };

    // --- CORE LOGIC ---
    const SHARP_SCALE = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
    const FLAT_SCALE = ['A', 'Bb', 'B', 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab'];
    const CHORD_REGEX_SOURCE = `[A-Ga-g]([#b])?(m|min|M|Maj|maj|aug|dim|sus|add|Δ|°|ø)?([1-9][0-5]?)?(\\((#|b)?[1-9][0-3]?((,|,\\s)*(\\s|#|b)?[1-9][0-3]?)*\\))?(sus[24]?)?([/\\\\][A-Ga-g]([#b])?)?`;
    const CHORD_REGEX_GLOBAL = new RegExp(`(${CHORD_REGEX_SOURCE}|[A-Ga-g]([#b])?[1-9][0-5]?|[A-Ga-g]([#b])?[1-9][0-5]?[Mm])`, 'g');
    function isChordToken(token) { 
        if (!token) return false; 
        const trimmed = token.trim();
        const regex = new RegExp(`^${CHORD_REGEX_SOURCE}$`); 
        const simpleChordRegex = /^[A-Ga-g][#b]?[1-9][0-5]?$/;
        const majorSeventhRegex = /^[A-Ga-g][#b]?[1-9][0-5]?[Mm]$/;
        return regex.test(trimmed) || simpleChordRegex.test(trimmed) || majorSeventhRegex.test(trimmed);
    }
    const isPotentiallyChordLine = (line) => { const t = line.trim(); if (!t || /^\[.*\]$/.test(t)) return false; const tokens = t.split(/\s+/).filter(Boolean); return tokens.length > 0 && tokens.every(isChordToken); };
    function transposeNote(n, a) { let s = n.includes('b') ? FLAT_SCALE : SHARP_SCALE; let i = s.indexOf(n); if (i === -1) return n; return s[(i + a + 12) % 12]; }
    function transposeChord(c, a) { if (a === 0) return c; const rm = c.match(/^[A-G](#|b)?/); if (!rm) return c; const [mc, bn] = c.split('/'); const r = rm[0]; const q = mc.substring(r.length); const nr = transposeNote(r, a); const tm = nr + q; return bn ? `${tm}/${transposeNote(bn, a)}` : tm; }
    function formatChordSequenceWithPatterns(chords, transposeAmount) { const tChords = chords.map(c => transposeChord(c, transposeAmount)); if (!tChords || tChords.length === 0) return ""; let r = [], i = 0; while (i < tChords.length) { let fp = false; for (let l = Math.floor((tChords.length - i) / 2); l >= 1; l--) { const p = tChords.slice(i, i + l); let rep = 1; while (i + (rep + 1) * l <= tChords.length) { const ns = tChords.slice(i + rep * l, i + (rep + 1) * l); if (JSON.stringify(p) === JSON.stringify(ns)) rep++; else break; } if (rep > 1) { r.push(`(${p.join(' ')}) ${rep}x`); i += rep * l; fp = true; break; } } if (!fp) { r.push(tChords[i]); i++; } } return r.join(' '); }
    function parseSong(text) { const lines = text.split('\n'), structure = []; let section = null; const create = n => ({ name: n, items: [], chordSequence: [] }); lines.forEach((l, i) => { const t = l.trim(); if (t.startsWith('[') && t.endsWith(']')) { section = create(t.substring(1, t.length - 1)); structure.push(section); return; } if (!section) { section = create('Introdução/Início'); structure.push(section); } if (t === "") { if (section.items.length > 0) section.items.push({ type: 'spacer' }); return; } if (isPotentiallyChordLine(l)) { const chords = l.match(CHORD_REGEX_GLOBAL) || []; section.chordSequence.push(...chords); const nl = lines[i + 1] || ''; if (nl.trim() && !isPotentiallyChordLine(nl) && !nl.trim().startsWith('[')) { section.items.push({ type: 'pair', chords: l, lyrics: nl }); } else { section.items.push({ type: 'chords', chords: l }); } } else { if (i === 0 || !isPotentiallyChordLine(lines[i - 1])) { section.items.push({ type: 'lyrics', lyrics: l }); } } }); return structure.filter(s => s.items.length > 0 || s.chordSequence.length > 0); }
    
    // --- API & AUTH FUNCTIONS ---
    async function fetchApi(path, options = {}) {
        const defaultOptions = { headers: { 'Content-Type': 'application/json' }, credentials: 'include' };
        const mergedOptions = { ...defaultOptions, ...options };
        if(options.body && typeof options.body !== 'string') mergedOptions.body = JSON.stringify(options.body);
        try { 
            const response = await fetch(path, mergedOptions); 
            if (!response.ok) { 
                if (response.status === 401) { 
                    showLoginScreen();
                    const errorData = await response.json().catch(() => ({error: "Não autorizado"}));
                    throw new Error(errorData.error);
                } 
                const errorData = await response.json().catch(() => ({error: "Erro desconhecido"})); 
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`); 
            } 
            if (response.status === 204 || (options.method && options.method.toUpperCase() === 'DELETE') || response.status === 201) { 
                return await response.json().catch(() => ({})); 
            } 
            return await response.json(); 
        } catch (error) { 
            console.error(`API Error on ${path}:`, error); 
            throw error; 
        }
    }
    async function checkAuthStatus() { try { const data = await fetchApi('/api/check_auth'); if (data && data.is_logged_in) { showApp(data.user); } else { showLoginScreen(); } } catch (e) { showLoginScreen(); } }
    async function handleLogin(event) { 
        event.preventDefault(); 
        
        // Adicionar estado de loading
        const submitBtn = event.target.querySelector('button[type="submit"]');
        const originalText = submitBtn.innerHTML;
        submitBtn.classList.add('btn-loading');
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Entrando...';
        
        dom.loginError.classList.add('hidden'); 
        const username = event.target.username.value; 
        const password = event.target.password.value; 
        
        try { 
            const data = await fetchApi('/api/login', { method: 'POST', body: { username, password } }); 
            if (data && data.user) { 
                // Adicionar efeito de sucesso
                submitBtn.innerHTML = '<i class="fas fa-check mr-2"></i>Sucesso!';
                submitBtn.classList.remove('btn-loading');
                submitBtn.classList.add('bg-green-600');
                
                setTimeout(() => {
                    showApp(data.user); 
                }, 500);
            } 
        } catch (e) { 
            // Restaurar botão
            submitBtn.classList.remove('btn-loading');
            submitBtn.innerHTML = originalText;
            
            dom.loginError.querySelector('p').textContent = e.message; 
            dom.loginError.classList.remove('hidden'); 
            
            // Adicionar shake animation
            const loginCard = document.querySelector('#login-container .bg-white\\/80');
            loginCard.style.animation = 'shake 0.5s ease-in-out';
            setTimeout(() => {
                loginCard.style.animation = '';
            }, 500);
        } 
    }
    async function handleLogout() { try { await fetchApi('/api/logout', { method: 'POST' }); } finally { showLoginScreen(); } }

    // --- SONGS FUNCTIONS ---
    async function loadSavedSongs(filter = 'my_songs') { 
        try { 
            const songs = await fetchApi(`/api/songs?filter=${filter}`); 
            dom.modalSongsList.innerHTML = ''; 
            if (!songs || songs.length === 0) { 
                dom.modalSongsList.innerHTML = `<p class="text-center text-gray-400 text-sm p-4">Nenhuma música ${filter === 'public' ? 'pública' : 'sua'} encontrada.</p>`; 
                return; 
            } 
            songs.forEach(song => { 
                const li = document.createElement('li'); 
                li.className = 'flex justify-between items-center p-2 hover:bg-blue-100 rounded'; 
                
                // Criar informações detalhadas
                const infoParts = [];
                if (song.original_key) infoParts.push(`Tom: ${song.original_key}`);
                if (song.capo_position && song.capo_position > 0) infoParts.push(`Capô: ${song.capo_position}ª`);
                if (song.bpm) infoParts.push(`BPM: ${song.bpm}`);
                if (song.duration) infoParts.push(`Duração: ${song.duration}`);
                
                const infoText = infoParts.length > 0 ? infoParts.join(' • ') : 'Sem informações';
                
                li.innerHTML = `
                    <div class="flex-1 cursor-pointer">
                        <div class="text-sm font-medium">${song.title}</div>
                        <div class="text-xs text-gray-500">${infoText}</div>
                    </div>
                    <div class="flex gap-2">
                        <button data-song-id="${song.id}" class="add-to-setlist-btn text-blue-500 hover:text-blue-700 p-1" title="Adicionar ao Setlist"><i class="fas fa-plus-circle"></i></button>
                        <button data-id="${song.id}" data-title="${song.title}" class="delete-song-btn text-red-500 hover:text-red-700 p-1" title="Deletar"><i class="fas fa-trash-alt fa-xs"></i></button>
                    </div>`; 
                li.querySelector('.flex-1').addEventListener('click', () => { handleLoadSong(song.id); dom.songsModal.close(); }); 
                dom.modalSongsList.appendChild(li); 
            }); 
        } catch (error) { 
            dom.modalSongsList.innerHTML = '<p class="text-center text-red-500 text-sm p-4">Erro ao carregar músicas.</p>'; 
        } 
    }
    async function handleLoadSong(songId) { 
        try { 
            const song = await fetchApi(`/api/songs/${songId}`); 
            dom.songInput.value = song.content; 
            
            // Define o ID da música atual
            state.currentSongId = songId;
            
            // Configura o capô antes de gerar a cifra
            if (song.capo_position !== undefined) { 
                state.capoPosition = song.capo_position; 
                dom.capoPosition.value = song.capo_position; 
            } 
            
            // Gera a cifra após configurar o capô
            handleGenerate();
            
            // Atualiza o status do capô após a geração
            updateCapoStatus(); 
            
            // Carrega dados de duração e BPM se disponíveis
            if (song.duration) {
                dom.songDuration.value = song.duration;
            }
            if (song.bpm) {
                dom.songBpm.value = song.bpm;
            }
            
            // Atualiza os dados da música atual
            state.currentSongData = { 
                title: song.title,
                duration: song.duration, 
                bpm: song.bpm,
                original_key: song.original_key
            };
            
            // Renderiza novamente para atualizar o cabeçalho com os dados corretos
            render();
            
        } catch (error) { 
            alert('Não foi possível carregar a música.'); 
        } 
    }
    async function handleDeleteSong(songId, songTitle) { if (confirm(`Tem certeza que deseja deletar "${songTitle}"?`)) { try { await fetchApi(`/api/songs/${songId}`, { method: 'DELETE' }); loadSavedSongs(dom.mySongsTab.classList.contains('active') ? 'my_songs' : 'public'); } catch (error) { alert(error.message); } } }
    async function handleSaveSong(event) { 
        event.preventDefault(); 
        const title = dom.songTitleInput.value; 
        const originalContent = dom.songInput.value; 
        // Aplica as transposições ao conteúdo antes de salvar
        const content = applyTranspositionsToContent(originalContent);
        const original_key = dom.originalKeyInput.value; 
        const duration = dom.songDuration.value;
        const bpm = parseInt(dom.songBpm.value) || null;
        const is_public = dom.isPublicCheckbox.checked; 
        // Garante que a posição do capô seja salva corretamente
        const capo_position = parseInt(dom.saveCapoPosition.value) || 0;
        
        if (!title || !content.trim()) { 
            alert('Título e conteúdo da cifra são obrigatórios.'); 
            return; 
        }
        
        // Validação da duração
        if (duration && !/^\d+:[0-5]\d$/.test(duration)) {
            alert('Formato de duração inválido. Use MM:SS (ex: 3:45)');
            return;
        }
        
        try { 
            if (state.currentSongId) {
                // Atualiza música existente
                await fetchApi(`/api/songs/${state.currentSongId}`, { 
                    method: 'PUT', 
                    body: { 
                        title, 
                        content, 
                        original_key, 
                        duration,
                        bpm,
                        is_public, 
                        capo_position 
                    } 
                }); 
                alert('Música atualizada com sucesso!');
            } else {
                // Cria nova música
                const result = await fetchApi('/api/songs', { 
                    method: 'POST', 
                    body: { 
                        title, 
                        content, 
                        original_key, 
                        duration,
                        bpm,
                        is_public, 
                        capo_position 
                    } 
                }); 
                // Se o backend retornar o ID da nova música, atualize o state.currentSongId
                if (result && result.id) {
                    state.currentSongId = result.id;
                }
                alert('Música salva com sucesso!');
            }
            
            // Atualiza os dados da música atual
            state.currentSongData = { 
                title, 
                duration, 
                bpm, 
                original_key 
            };
            
            // Atualiza a posição do capô no estado
            state.capoPosition = capo_position;
            dom.capoPosition.value = capo_position;
            
            // Atualiza o status do capô e renderiza novamente
            updateCapoStatus();
            render();
            
            dom.saveModal.close(); 
            dom.saveForm.reset(); 
        } catch (error) { 
            alert('Não foi possível salvar a música.'); 
        } 
    }
    
    // --- USER MANAGEMENT FUNCTIONS ---
    async function handleCreateUser(event) { 
        event.preventDefault(); 
        dom.createUserFeedback.classList.add('hidden'); 
        const username = dom.createUserForm['new-username'].value; 
        const password = dom.createUserForm['create-user-password'].value;
        try { 
            const data = await fetchApi('/api/users', { method: 'POST', body: { username, password } }); 
            dom.createUserFeedback.textContent = data.message; 
            dom.createUserFeedback.className = 'text-sm mt-4 text-green-600'; 
            dom.createUserForm.reset(); 
            setTimeout(() => dom.createUserModal.close(), 1500); 
            handleOpenUserManagement(); 
        } catch (error) { 
            dom.createUserFeedback.textContent = error.message; 
            dom.createUserFeedback.className = 'text-sm mt-4 text-red-600'; 
        } finally { 
            dom.createUserFeedback.classList.remove('hidden'); 
        } 
    }
    async function handleOpenUserManagement() { try { const users = await fetchApi('/api/users'); dom.modalUsersList.innerHTML = ''; if (!users || users.length === 0) return; users.forEach(user => { const li = document.createElement('li'); li.className = 'flex justify-between items-center p-2'; li.innerHTML = `<span class="text-sm">${user.username}</span>`; if (user.username !== 'admin') { li.innerHTML += `<button data-id="${user.id}" data-username="${user.username}" class="delete-user-btn text-red-500 hover:text-red-700 p-1" title="Deletar"><i class="fas fa-trash-alt fa-xs"></i></button>`; } dom.modalUsersList.appendChild(li); }); dom.userManagementModal.showModal(); } catch (error) { alert("Não foi possível carregar a lista de usuários."); } }
    async function handleDeleteUserFromModal(e) { if (!e.target.closest('.delete-user-btn')) return; const btn = e.target.closest('.delete-user-btn'); const userId = btn.dataset.id; const username = btn.dataset.username; if (confirm(`Tem certeza que deseja deletar o usuário "${username}"?`)) { try { await fetchApi(`/api/users/${userId}`, { method: 'DELETE' }); handleOpenUserManagement(); } catch (error) { alert('Não foi possível deletar o usuário.'); } } }
    async function handleChangePassword(e) { e.preventDefault(); dom.changePasswordFeedback.classList.add('hidden'); const old_password = dom.changePasswordForm['old-password'].value; const new_password = dom.changePasswordForm['new-password'].value; try { const data = await fetchApi('/api/users/change_password', { method: 'POST', body: { old_password, new_password } }); dom.changePasswordFeedback.textContent = data.message; dom.changePasswordFeedback.className = 'text-sm mt-4 text-green-600'; dom.changePasswordForm.reset(); setTimeout(() => dom.changePasswordModal.close(), 1500); } catch (error) { dom.changePasswordFeedback.textContent = error.message; dom.changePasswordFeedback.className = 'text-sm mt-4 text-red-600'; } finally { dom.changePasswordFeedback.classList.remove('hidden'); } }

    // --- SETLISTS FUNCTIONS ---
    async function handleOpenSetlistsModal() {
        dom.setlistsTabsNav.classList.remove('hidden');
        dom.createSetlistForm.classList.remove('hidden');
        dom.setlistsModalTitle.textContent = 'Gerenciar Setlists';
        dom.mySetlistsTab.classList.add('active');
        dom.publicSetlistsTab.classList.remove('active');
        const backButton = dom.setlistsModal.querySelector('.back-to-setlist-list');
        if (backButton) backButton.remove();
        
        await loadSetlists('my_setlists');
        dom.setlistsModal.showModal();
    }
    async function loadSetlists(filter = 'my_setlists') {
        try {
            const setlists = await fetchApi(`/api/setlists?filter=${filter}`);
            dom.modalSetlistsList.innerHTML = '';
            if (!setlists || setlists.length === 0) {
                dom.modalSetlistsList.innerHTML = `<p class="text-center text-gray-400 text-sm p-4">Nenhum setlist encontrado.</p>`;
                return;
            }
            setlists.forEach(setlist => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center p-2 hover:bg-indigo-100 rounded';
                li.innerHTML = `
                    <div class="flex-1 truncate cursor-pointer view-setlist-btn" data-id="${setlist.id}">
                        <span class="text-sm font-medium">${setlist.name}</span>
                    </div>
                    <div class="flex gap-2">
                        <button data-id="${setlist.id}" data-name="${setlist.name}" class="delete-setlist-btn text-red-500 hover:text-red-700 p-1" title="Deletar">
                            <i class="fas fa-trash-alt fa-xs"></i>
                        </button>
                    </div>`;
                dom.modalSetlistsList.appendChild(li);
            });
        } catch (error) {
            dom.modalSetlistsList.innerHTML = '<p class="text-center text-red-500 text-sm p-4">Erro ao carregar setlists.</p>';
        }
    }
    async function handleCreateSetlist(event) {
        event.preventDefault();
        dom.createSetlistFeedback.classList.add('hidden');
        const form = event.target;
        const name = form['setlist-name-input'].value;
        const is_public = form['setlist-is-public-checkbox'].checked;
        if (!name.trim()) { alert('O nome do setlist não pode estar em branco.'); return; }
        try {
            await fetchApi('/api/setlists', { method: 'POST', body: { name, is_public } });
            form.reset();
            await loadSetlists(dom.mySetlistsTab.classList.contains('active') ? 'my_setlists' : 'public');
        } catch (error) {
            dom.createSetlistFeedback.textContent = `Erro: ${error.message}`;
            dom.createSetlistFeedback.className = 'text-sm mt-2 text-red-600';
            dom.createSetlistFeedback.classList.remove('hidden');
        }
    }
    async function viewSetlist(setlistId) {
        try {
            const data = await fetchApi(`/api/setlists/${setlistId}`);
            dom.setlistsTabsNav.classList.add('hidden');
            dom.createSetlistForm.classList.add('hidden');
            dom.setlistsModalTitle.textContent = data.name;

            const backButton = document.createElement('button');
            backButton.innerHTML = '&larr; Voltar para a lista';
            backButton.className = 'text-sm text-indigo-600 hover:underline mb-4 back-to-setlist-list';
            backButton.onclick = () => handleOpenSetlistsModal();

            const listContainer = dom.modalSetlistsList;
            listContainer.innerHTML = '';
            dom.setlistsViewContainer.after(listContainer); 
            listContainer.before(backButton);

            // Adicionar controles de visibilidade e adicionar músicas
            if (data.is_owner) {
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'flex justify-between items-center p-3 bg-gray-50 border-b';
                
                // Controle de visibilidade
                const visibilityDiv = document.createElement('div');
                visibilityDiv.className = 'flex items-center gap-2';
                
                const visibilityLabel = document.createElement('label');
                visibilityLabel.className = 'text-sm font-medium text-gray-700';
                visibilityLabel.textContent = 'Público:';
                visibilityDiv.appendChild(visibilityLabel);
                
                const visibilityToggle = document.createElement('input');
                visibilityToggle.type = 'checkbox';
                visibilityToggle.className = 'h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500';
                visibilityToggle.checked = data.is_public;
                visibilityToggle.onchange = async () => {
                    try {
                        await fetchApi(`/api/setlists/${setlistId}/visibility`, {
                            method: 'PUT',
                            body: { is_public: visibilityToggle.checked }
                        });
                    } catch (error) {
                        alert(`Erro ao atualizar visibilidade: ${error.message}`);
                        visibilityToggle.checked = !visibilityToggle.checked; // Reverter mudança
                    }
                };
                visibilityDiv.appendChild(visibilityToggle);
                
                controlsDiv.appendChild(visibilityDiv);
                
                // Botão para adicionar músicas
                const addSongsBtn = document.createElement('button');
                addSongsBtn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-sm';
                addSongsBtn.textContent = 'Adicionar Músicas';
                addSongsBtn.onclick = () => handleOpenAddSongsToSetlistModal(setlistId);
                controlsDiv.appendChild(addSongsBtn);
                
                listContainer.appendChild(controlsDiv);
            }

            if (data.songs && data.songs.length > 0) {
                data.songs.forEach(song => {
                    const songLi = document.createElement('li');
                    songLi.className = 'flex justify-between items-center p-2 border-b';
                    songLi.dataset.songId = song.id;

                    const titleContainer = document.createElement('div');
                    titleContainer.className = 'flex items-center flex-grow cursor-pointer';
                    titleContainer.onclick = () => {
                        handleLoadSong(song.id);
                        dom.setlistsModal.close();
                    };

                    if (data.is_owner) {
                        const handleIcon = document.createElement('i');
                        handleIcon.className = 'fas fa-grip-vertical text-gray-400 mr-3 handle';
                        titleContainer.appendChild(handleIcon);
                    }
                    
                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = song.title;
                    titleContainer.appendChild(titleSpan);
                    
                    // Adicionar informações da música
                    const infoParts = [];
                    if (song.original_key) infoParts.push(`Tom: ${song.original_key}`);
                    if (song.capo_position && song.capo_position > 0) infoParts.push(`Capô: ${song.capo_position}ª`);
                    if (song.bpm) infoParts.push(`BPM: ${song.bpm}`);
                    if (song.duration) infoParts.push(`Duração: ${song.duration}`);
                    
                    if (infoParts.length > 0) {
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'text-xs text-gray-500 mt-1';
                        infoDiv.textContent = infoParts.join(' • ');
                        titleContainer.appendChild(infoDiv);
                    }
                    songLi.appendChild(titleContainer);

                    if (data.is_owner) {
                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'remove-song-from-setlist-btn text-red-500 hover:text-red-700 p-1';
                        removeBtn.title = 'Remover do Setlist';
                        removeBtn.dataset.songId = song.id;
                        removeBtn.dataset.setlistId = setlistId;
                        removeBtn.innerHTML = '<i class="fas fa-times-circle"></i>';
                        songLi.appendChild(removeBtn);
                    }
                    listContainer.appendChild(songLi);
                });
            } else {
                const emptyMessage = document.createElement('p');
                emptyMessage.className = 'text-center text-gray-400 text-sm p-4';
                emptyMessage.textContent = 'Este setlist está vazio.';
                listContainer.appendChild(emptyMessage);
            }

            if (data.is_owner) {
                new Sortable(listContainer, {
                    handle: '.handle',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    onEnd: async function (evt) {
                        const items = Array.from(listContainer.children);
                        const songIds = items.map(item => parseInt(item.dataset.songId)).filter(id => !isNaN(id));
                        try {
                            await fetchApi(`/api/setlists/${setlistId}/songs/order`, {
                                method: 'PUT',
                                body: { song_ids: songIds }
                            });
                        } catch (error) {
                            alert('Não foi possível salvar a nova ordem.');
                        }
                    }
                });
            }

        } catch (error) {
            alert(`Erro ao carregar o setlist: ${error.message}`);
        }
    }
    async function handleOpenAddToSetlistModal(songId) {
        try {
            const mySetlists = await fetchApi('/api/setlists?filter=my_setlists');
            dom.setlistSelect.innerHTML = '';
            if (mySetlists && mySetlists.length > 0) {
                mySetlists.forEach(setlist => {
                    const option = document.createElement('option');
                    option.value = setlist.id;
                    option.textContent = setlist.name;
                    dom.setlistSelect.appendChild(option);
                });
                dom.addToSetlistModal.dataset.songId = songId;
                dom.addToSetlistModal.showModal();
            } else {
                alert('Você precisa criar um setlist primeiro!');
            }
        } catch (error) {
            alert('Erro ao carregar seus setlists.');
        }
    }
    async function handleAddToSetlistSubmit(event) {
        event.preventDefault();
        const songId = dom.addToSetlistModal.dataset.songId;
        const setlistId = dom.setlistSelect.value;
        if (!songId || !setlistId) {
            alert('Erro: Música ou setlist não selecionado.');
            return;
        }
        try {
            await fetchApi(`/api/setlists/${setlistId}/songs`, {
                method: 'POST',
                body: { song_id: songId }
            });
            dom.addToSetlistModal.close();
            alert('Música adicionada com sucesso!');
        } catch (error) {
            alert(`Erro: ${error.message}`);
        }
    }

    async function handleOpenAddSongsToSetlistModal(setlistId) {
        try {
            const availableSongs = await fetchApi(`/api/setlists/${setlistId}/available-songs`);
            dom.availableSongsList.innerHTML = '';
            
            if (!availableSongs || availableSongs.length === 0) {
                dom.availableSongsList.innerHTML = '<p class="text-center text-gray-400 text-sm p-4">Você não tem músicas salvas disponíveis para adicionar a este setlist.</p>';
            } else {
                availableSongs.forEach(song => {
                    const songLi = document.createElement('li');
                    songLi.className = 'flex justify-between items-center p-2 hover:bg-indigo-100 rounded cursor-pointer add-song-to-setlist-btn';
                    songLi.dataset.songId = song.id;
                    songLi.dataset.setlistId = setlistId;
                    
                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = song.title;
                    songLi.appendChild(titleSpan);
                    
                    // Adicionar informações da música
                    const infoParts = [];
                    if (song.original_key) infoParts.push(`Tom: ${song.original_key}`);
                    if (song.capo_position && song.capo_position > 0) infoParts.push(`Capô: ${song.capo_position}ª`);
                    if (song.bpm) infoParts.push(`BPM: ${song.bpm}`);
                    if (song.duration) infoParts.push(`Duração: ${song.duration}`);
                    
                    if (infoParts.length > 0) {
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'text-xs text-gray-500 mt-1';
                        infoDiv.textContent = infoParts.join(' • ');
                        songLi.appendChild(infoDiv);
                    }
                    
                    const addIcon = document.createElement('i');
                    addIcon.className = 'fas fa-plus text-indigo-600';
                    songLi.appendChild(addIcon);
                    
                    songLi.onclick = () => handleAddSongToSetlist(song.id, setlistId, song.title);
                    dom.availableSongsList.appendChild(songLi);
                });
            }
            
            dom.addSongsToSetlistModal.showModal();
        } catch (error) {
            alert(`Erro ao carregar músicas disponíveis: ${error.message}`);
        }
    }

    async function handleAddSongToSetlist(songId, setlistId, songTitle) {
        try {
            await fetchApi(`/api/setlists/${setlistId}/songs`, {
                method: 'POST',
                body: { song_id: songId }
            });
            
            // Remover a música da lista de disponíveis
            const songElement = dom.availableSongsList.querySelector(`[data-song-id="${songId}"]`);
            if (songElement) {
                songElement.remove();
            }
            
            // Se não há mais músicas disponíveis, fechar o modal
            if (dom.availableSongsList.children.length === 0) {
                dom.addSongsToSetlistModal.close();
            }
            
            alert(`Música "${songTitle}" adicionada com sucesso!`);
        } catch (error) {
            alert(`Erro ao adicionar música: ${error.message}`);
        }
    }

    // --- UI/DISPLAY LOGIC ---
    function showApp(user) { 
        dom.loginContainer.classList.add('hidden'); 
        dom.appContainer.classList.remove('hidden'); 
        dom.appContainer.classList.add('flex'); 
        dom.welcomeUser.textContent = `Olá, ${user.username}`; 
        [dom.logoutBtn, dom.fullscreenBtn, dom.changePasswordBtn].forEach(b => b.classList.remove('hidden')); 
        dom.manageUsersBtn.classList.toggle('hidden', !user.is_admin); 
        
        // Inicializa o estado da música se não existir
        if (!state.currentSongData) {
            state.currentSongData = { 
                title: 'Nova música',
                duration: '',
                bpm: null,
                original_key: ''
            };
        }
        
        handleGenerate();
    }
    function showLoginScreen() { 
        dom.loginContainer.classList.remove('hidden'); 
        dom.appContainer.classList.add('hidden'); 
        dom.appContainer.classList.remove('flex'); 
        [dom.logoutBtn, dom.fullscreenBtn, dom.changePasswordBtn, dom.manageUsersBtn].forEach(b => { if (b) b.classList.add('hidden'); });
    }

    // --- RENDERING LOGIC ---
    function applyStyles() { const e = document.getElementById('dynamic-styles'); if (e) e.remove(); const s = document.createElement("style"); s.id = 'dynamic-styles'; s.innerText = `.lyric-output{font-size:${dom.lyricsSizeSlider.value}px;color:${dom.lyricsColorPicker.value};}.chord-output,.summary-chord{font-size:${dom.chordsSizeSlider.value}px;color:${dom.chordsColorPicker.value};}`; document.head.appendChild(s); }
    function render() { 
        applyStyles(); 
        if (state.songStructure.length === 0) { 
            dom.outputArea.innerHTML = '<p class="text-gray-500 italic">Gere uma cifra ou carregue uma música salva.</p>'; 
            dom.summaryArea.innerHTML = ''; 
            dom.uniqueChordsArea.innerHTML = ''; 
            return; 
        } 
        
        dom.outputArea.innerHTML = '';
        
        // Adiciona o cabeçalho com título da música e tom (fixo, fora das colunas)
        const songHeader = document.createElement('div');
        songHeader.className = 'flex justify-center items-center p-3 mb-4 bg-blue-50 rounded-md w-full sticky top-0 z-10';
        
        // Container central para título e tom
        const titleKeyInfo = document.createElement('div');
        titleKeyInfo.className = 'text-sm font-medium text-blue-800 text-center';
        
        // Determina o título da música
        const songTitle = state.currentSongData?.title || 'Música sem título';
        
        // Determina o tom da música
        let songKey = '';
        if (state.currentSongData?.original_key) {
            // Usa o tom original salvo com a música
            songKey = state.currentSongData.original_key;
        } else {
            // Calcula o tom baseado nos acordes
            const currentKey = detectCurrentKey();
            if (currentKey) {
                songKey = currentKey;
            }
        }
        
        // Texto do título e tom
        let headerText = songTitle + (songKey ? ` - Tom ${songKey}` : '');
        
        // Adiciona informação do capô (se aplicável)
        if (state.capoPosition > 0) {
            const currentKey = songKey || detectCurrentKey();
            if (currentKey) {
                const referenceKey = calculateOriginalKey(currentKey, state.capoPosition);
                headerText += ` | Capô ${state.capoPosition} (acordes no formato de ${referenceKey})`;
            } else {
                headerText += ` | Capô ${state.capoPosition}`;
            }
        }
        
        titleKeyInfo.textContent = headerText;
        songHeader.appendChild(titleKeyInfo);
        
        dom.outputArea.appendChild(songHeader);
        
        // Cria um container para o conteúdo da cifra (que será dividido em colunas)
        const contentContainer = document.createElement('div');
        contentContainer.className = 'chord-content-container w-full mt-2';
        dom.outputArea.appendChild(contentContainer);
        
        // Se estiver em modo de 2 colunas, distribuir o conteúdo
        if (state.isTwoColumns) {
            const sections = [];
            
            state.songStructure.forEach(s => { 
                const d = document.createElement('div'); 
                d.className = 'mb-6 section-container'; 
                const h = document.createElement('h3'); 
                h.className = 'text-lg font-bold text-gray-800 mb-2'; 
                h.textContent = s.name; 
                d.appendChild(h); 
                
                s.items.forEach(i => { 
                    if (i.type === 'pair' || i.type === 'chords') { 
                        const cd = document.createElement('div'); 
                        cd.className = 'chord-output mb-1'; 
                        cd.textContent = i.chords.replace(CHORD_REGEX_GLOBAL, match => transposeChord(match, getTotalTranspose())); 
                        d.appendChild(cd); 
                    } 
                    if (i.type === 'pair') { 
                        const ld = document.createElement('div'); 
                        ld.className = 'lyric-output'; 
                        ld.textContent = i.lyrics; 
                        d.appendChild(ld); 
                    } 
                    if (i.type === 'lyrics') { 
                        const ld = document.createElement('div'); 
                        ld.className = 'lyric-output'; 
                        ld.textContent = i.lyrics; 
                        d.appendChild(ld); 
                    } 
                    if (i.type === 'spacer') { 
                        const sd = document.createElement('div'); 
                        sd.className = 'h-4'; 
                        d.appendChild(sd); 
                    } 
                }); 
                
                if (state.currentView === 'map') { 
                    const b = document.createElement('div'); 
                    b.className = 'mt-3 p-2 bg-gray-50 rounded-md text-sm flex flex-wrap items-baseline gap-x-2'; 
                    const titleSpan = document.createElement('span'); 
                    titleSpan.className = 'font-semibold text-gray-600'; 
                    titleSpan.textContent = 'Sequência:'; 
                    const chordSpan = document.createElement('span'); 
                    chordSpan.className = 'summary-chord break-words'; 
                    chordSpan.textContent = formatChordSequenceWithPatterns(s.chordSequence, getTotalTranspose()); 
                    b.appendChild(titleSpan); 
                    b.appendChild(chordSpan); 
                    d.appendChild(b); 
                } 
                
                sections.push(d);
            });
            
            // Distribuir seções entre as colunas de forma equilibrada, mantendo a ordem sequencial
            const leftColumn = [];
            const rightColumn = [];
            
            // Estimar o tamanho de cada seção de forma mais precisa
            const sectionSizes = sections.map((section, index) => {
                // Contar o número de elementos filhos
                const childCount = section.childElementCount;
                
                // Contar o número de quebras de linha no texto como estimativa de altura
                const textContent = section.textContent || '';
                const lineBreaks = (textContent.match(/\n/g) || []).length;
                
                // Contar elementos específicos que ocupam mais espaço
                const chordOutputs = section.querySelectorAll('.chord-output').length;
                const lyricOutputs = section.querySelectorAll('.lyric-output').length;
                
                // Calcular tamanho estimado com base em todos esses fatores
                return { 
                    index, 
                    size: childCount + lineBreaks + (chordOutputs * 1.5) + lyricOutputs + (textContent.length / 50)
                };
            });
            
            // Calcular o tamanho total de todas as seções
            const totalSize = sectionSizes.reduce((sum, section) => sum + section.size, 0);
            
            // Definir um limite ideal para a primeira coluna (50% do total)
            // para garantir uma distribuição equilibrada
            const targetFirstColumnSize = totalSize * 0.5;
            
            // Distribuir as seções em ordem sequencial, buscando equilíbrio entre as colunas
            let leftSize = 0;
            
            // Primeira passagem: colocar seções na coluna esquerda até aproximar-se do alvo de 50%
            for (let i = 0; i < sections.length; i++) {
                // Adicionar a seção atual à coluna esquerda
                leftColumn.push(sections[i]);
                leftSize += sectionSizes[i].size;
                
                // Se já ultrapassamos 45% do tamanho total e não estamos na primeira seção
                // E a próxima seção faria ultrapassar significativamente os 50%
                if (i > 0 && leftSize >= targetFirstColumnSize * 0.9) {
                    // Verificar se adicionar a próxima seção causaria um desequilíbrio maior
                    if (i + 1 < sections.length) {
                        const nextSectionSize = sectionSizes[i + 1].size;
                        // Se adicionar a próxima seção ultrapassaria muito os 50%, paramos aqui
                        if (leftSize + nextSectionSize > targetFirstColumnSize * 1.1) {
                            break;
                        }
                    } else {
                        // Se não há próxima seção, paramos aqui
                        break;
                    }
                }
            }
            
            // Segunda passagem: colocar as seções restantes na coluna direita
            for (let i = leftColumn.length; i < sections.length; i++) {
                rightColumn.push(sections[i]);
            }
            
            // Criar containers para as colunas
            const leftContainer = document.createElement('div');
            leftContainer.className = 'column-container';
            leftColumn.forEach(section => leftContainer.appendChild(section));
            
            const rightContainer = document.createElement('div');
            rightContainer.className = 'column-container';
            rightColumn.forEach(section => rightContainer.appendChild(section));
            
            // Adiciona as colunas ao contentContainer em vez de diretamente ao outputArea
            contentContainer.appendChild(leftContainer);
            contentContainer.appendChild(rightContainer);
            
        } else {
            // Modo de 1 coluna (comportamento original)
            state.songStructure.forEach(s => { 
                const d = document.createElement('div'); 
                d.className = 'mb-6 section-container'; 
                const h = document.createElement('h3'); 
                h.className = 'text-lg font-bold text-gray-800 mb-2'; 
                h.textContent = s.name; 
                d.appendChild(h); 
                
                s.items.forEach(i => { 
                    if (i.type === 'pair' || i.type === 'chords') { 
                        const cd = document.createElement('div'); 
                        cd.className = 'chord-output mb-1'; 
                        cd.textContent = i.chords.replace(CHORD_REGEX_GLOBAL, match => transposeChord(match, getTotalTranspose())); 
                        d.appendChild(cd); 
                    } 
                    if (i.type === 'pair') { 
                        const ld = document.createElement('div'); 
                        ld.className = 'lyric-output'; 
                        ld.textContent = i.lyrics; 
                        d.appendChild(ld); 
                    } 
                    if (i.type === 'lyrics') { 
                        const ld = document.createElement('div'); 
                        ld.className = 'lyric-output'; 
                        ld.textContent = i.lyrics; 
                        d.appendChild(ld); 
                    } 
                    if (i.type === 'spacer') { 
                        const sd = document.createElement('div'); 
                        sd.className = 'h-4'; 
                        d.appendChild(sd); 
                    } 
                }); 
                
                if (state.currentView === 'map') { 
                    const b = document.createElement('div'); 
                    b.className = 'mt-3 p-2 bg-gray-50 rounded-md text-sm flex flex-wrap items-baseline gap-x-2'; 
                    const titleSpan = document.createElement('span'); 
                    titleSpan.className = 'font-semibold text-gray-600'; 
                    titleSpan.textContent = 'Sequência:'; 
                    const chordSpan = document.createElement('span'); 
                    chordSpan.className = 'summary-chord break-words'; 
                    chordSpan.textContent = formatChordSequenceWithPatterns(s.chordSequence, getTotalTranspose()); 
                    b.appendChild(titleSpan); 
                    b.appendChild(chordSpan); 
                    d.appendChild(b); 
                } 
                
                contentContainer.appendChild(d); 
            });
        }
        
        const allChords = [...new Set(state.songStructure.flatMap(s => s.chordSequence))].map(c => transposeChord(c, getTotalTranspose())); 
        // Mostrar as Notas da Música apenas quando estiver no modo mapa
        if (state.currentView === 'map') {
            dom.uniqueChordsArea.innerHTML = `<h2 class="text-xl font-bold text-gray-800 mb-2 mt-4 border-t pt-4">Notas da Música</h2><div class="flex flex-wrap gap-2">${allChords.map(c => `<span class="bg-gray-200 text-gray-800 px-3 py-1 rounded-md text-sm font-medium">${c}</span>`).join('')}</div>`;
        } else {
            dom.uniqueChordsArea.innerHTML = ''; // Limpa a área se não estiver no modo mapa
        }
        if (state.currentView === 'map') {
            dom.summaryArea.innerHTML = `<h2 class="text-xl font-bold text-gray-800 mb-2 mt-4 border-t pt-4">Estrutura Completa</h2><div class="p-4 bg-blue-50 rounded-lg text-sm leading-relaxed">${state.songStructure.filter(s => s.chordSequence.length > 0).map(s => `<strong class="text-blue-800">[${s.name}]</strong> <span class="summary-chord">(${formatChordSequenceWithPatterns(s.chordSequence, getTotalTranspose())})</span>`).join(' <span class="font-bold text-blue-400">&rarr;</span> ')}</div>`; 
        } else {
            dom.summaryArea.innerHTML = ''; // Limpa a área se não estiver no modo mapa
        } 
    }

    // --- UI EVENT HANDLERS ---
    function handleModalListClick(event) {
        const deleteSongBtn = event.target.closest('.delete-song-btn');
        if (deleteSongBtn) {
            event.stopPropagation();
            handleDeleteSong(deleteSongBtn.dataset.id, deleteSongBtn.dataset.title);
            return;
        }
        const addToSetlistBtn = event.target.closest('.add-to-setlist-btn');
        if (addToSetlistBtn) {
            event.stopPropagation();
            handleOpenAddToSetlistModal(addToSetlistBtn.dataset.songId);
            return;
        }
    }
    async function handleSetlistsListClick(event) {
        const viewBtn = event.target.closest('.view-setlist-btn');
        if (viewBtn) {
            event.stopPropagation();
            viewSetlist(viewBtn.dataset.id);
            return;
        }
        const deleteBtn = event.target.closest('.delete-setlist-btn');
        if (deleteBtn) {
            event.stopPropagation();
            const setlistId = deleteBtn.dataset.id;
            const setlistName = deleteBtn.dataset.name;
            if (confirm(`Tem certeza que deseja deletar o setlist "${setlistName}"?`)) {
                try {
                    await fetchApi(`/api/setlists/${setlistId}`, { method: 'DELETE' });
                    loadSetlists(dom.mySetlistsTab.classList.contains('active') ? 'my_setlists' : 'public');
                } catch (error) {
                    alert(`Erro ao deletar o setlist: ${error.message}`);
                }
            }
            return;
        }
        const removeSongBtn = event.target.closest('.remove-song-from-setlist-btn');
        if (removeSongBtn) {
            event.stopPropagation();
            const songId = removeSongBtn.dataset.songId;
            const setlistId = removeSongBtn.dataset.setlistId;
            if (confirm('Remover esta música do setlist?')) {
                try {
                    await fetchApi(`/api/setlists/${setlistId}/songs/${songId}`, { method: 'DELETE' });
                    viewSetlist(setlistId);
                } catch (error) {
                    alert(`Erro ao remover música: ${error.message}`);
                }
            }
            return;
        }
    }
    function handleGenerate() { 
        state.songStructure = parseSong(dom.songInput.value); 
        state.transposeAmount = 0; 
        
        // Não resetar a posição do capô se estiver carregando uma música existente
        if (!state.currentSongId) {
            state.capoPosition = 0;
            dom.capoPosition.value = 0;
        }
        
        updateTransposeStatus(); 
        updateCapoStatus(); 
        resetScroll();
        render(); 
    }
    function handleClearInput() { 
        dom.songInput.value = ''; 
        state.currentSongId = null; // Limpa o ID da música atual
        // Mantém um título padrão em vez de definir como null
        state.currentSongData = { 
            title: 'Nova música',
            duration: '',
            bpm: null,
            original_key: ''
        };
        handleGenerate(); 
    }
    function handleTranspose(a) { state.transposeAmount += a; updateTransposeStatus(); render(); }
    function updateTransposeStatus() { dom.transposeStatus.textContent = state.transposeAmount === 0 ? 'Original' : `${state.transposeAmount > 0 ? '+' : ''}${state.transposeAmount}`; }
    
    // Função para obter a transposição total (manual + capô)
    function getTotalTranspose() {
        // Transposição manual + efeito do capô (que é negativo)
        // Quando o capô está na casa 2, os acordes devem ser transpostos 2 semitons abaixo
        return state.transposeAmount - state.capoPosition;
    }
    
    // Função para detectar o tom atual baseado nos acordes da música
    function detectCurrentKey() {
        // Se já temos um tom original salvo, use-o como prioridade
        if (state.currentSongData && state.currentSongData.original_key) {
            return state.currentSongData.original_key.toUpperCase();
        }
        
        const content = dom.songInput.value;
        const chords = content.match(CHORD_REGEX_GLOBAL) || [];
        
        if (chords.length === 0) {
            return null;
        }
        
        // Conta a frequência de cada acorde
        const chordCount = {};
        const noteCount = {};
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Inicializa contagem de notas
        notes.forEach(note => noteCount[note] = 0);
        
        chords.forEach(chord => {
            // Extrai a nota base do acorde (C, D, Em, etc)
            const baseNote = chord.match(/^[A-G][#b]?/i)?.[0] || '';
            if (baseNote) {
                // Normaliza para maiúsculo
                const normalizedNote = baseNote.toUpperCase();
                // Incrementa contagem da nota
                noteCount[normalizedNote] = (noteCount[normalizedNote] || 0) + 1;
            }
            
            // Também mantém contagem do acorde completo para análise secundária
            chordCount[chord] = (chordCount[chord] || 0) + 1;
        });
        
        // Encontra a nota mais frequente
        let mostFrequentNote = null;
        let maxNoteCount = 0;
        
        for (const [note, count] of Object.entries(noteCount)) {
            if (count > maxNoteCount) {
                maxNoteCount = count;
                mostFrequentNote = note;
            }
        }
        
        // Se encontrou uma nota frequente, retorna
        if (mostFrequentNote) {
            return mostFrequentNote;
        }
        
        // Abordagem alternativa: primeiro acorde da música
        if (chords.length > 0) {
            const firstChord = chords[0];
            const baseNote = firstChord.match(/^[A-G][#b]?/i)?.[0] || '';
            if (baseNote) {
                return baseNote.toUpperCase();
            }
        }
        
        // Retorna null se não conseguir determinar o tom
        return null;
    }
    
    // Função para calcular o tom de referência baseado no tom atual e posição do capô
    function calculateOriginalKey(currentKey, capoPosition) {
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const currentIndex = notes.indexOf(currentKey.toUpperCase());
        
        if (currentIndex === -1) return currentKey; // Se não encontrar, retorna o original
        
        // Calcula o tom de referência (formato dos acordes quando se usa capô)
        // Quando o capô está na casa 2 e a música soa em E, os acordes estão escritos em D
        // Isso significa que os acordes estão capoPosition semitons ABAIXO do tom que soa
        const referenceIndex = (currentIndex - capoPosition + 12) % 12;
        return notes[referenceIndex];
    }
    
    // Função para aplicar transposições ao conteúdo da cifra
    function applyTranspositionsToContent(content) {
        if (!content) return content;
        
        // Ao salvar, não devemos aplicar a transposição do capô, apenas a transposição manual
        // Isso evita que a música seja salva com um tom acima a cada salvamento
        const transposeAmount = state.transposeAmount;
        if (transposeAmount === 0) return content;
        
        // Processa o conteúdo linha por linha para evitar transpor texto que não são acordes
        const lines = content.split('\n');
        
        return lines.map(line => {
            // Verifica se a linha contém potencialmente acordes
            if (isPotentiallyChordLine(line)) {
                // Aplica transposição apenas aos acordes na linha
                return line.replace(CHORD_REGEX_GLOBAL, match => {
                    return transposeChord(match, transposeAmount);
                });
            }
            // Retorna a linha sem alterações se não for uma linha de acordes
            return line;
        }).join('\n');
    }
    
    // Função para lidar com mudança no capô
    function handleCapoChange() {
        state.capoPosition = parseInt(dom.capoPosition.value);
        updateCapoStatus();
        render();
    }
    
    // Função para atualizar o status do capô
    function updateCapoStatus() {
        dom.capoStatus.textContent = state.capoPosition;
        if (state.capoPosition === 0) {
            dom.capoInfo.textContent = 'Sem capô';
        } else {
            // Determina o tom atual da música
            const currentKey = detectCurrentKey();
            if (currentKey) {
                // Calcula o tom dos acordes (formato dos acordes quando se usa capô)
                // Os acordes estão escritos em um tom menor que o tom que soa
                const chordKey = calculateOriginalKey(currentKey, state.capoPosition);
                dom.capoInfo.textContent = `Capô na ${state.capoPosition}ª casa (acordes em ${chordKey}, soa em ${currentKey})`;
            } else {
                dom.capoInfo.textContent = `Capô na ${state.capoPosition}ª casa (+${state.capoPosition} semitons)`;
            }
        }
    }
    function handleViewModeToggle() { 
        state.currentView = state.currentView === 'chart' ? 'map' : 'chart'; 
        dom.viewModeToggle.textContent = state.currentView === 'chart' ? 'Ver Mapa' : 'Ver Cifra'; 
        // Atualiza o atributo data-view no body para controle via CSS
        if (state.currentView === 'map') {
            document.body.setAttribute('data-view', 'map');
        } else {
            document.body.removeAttribute('data-view');
        }
        render(); 
    }
    function handleColumnsToggle() { 
        state.isTwoColumns = !state.isTwoColumns; 
        dom.outputArea.classList.toggle('two-columns', state.isTwoColumns); 
        dom.columnsToggle.textContent = state.isTwoColumns ? 'Usar 1 Coluna' : 'Usar 2 Colunas'; 
        // Renderizar novamente para garantir que o layout seja aplicado corretamente
        render();
    }
    function handleDeviceViewToggle(d) { dom.viewWrapper.classList.remove('view-desktop', 'view-tablet', 'view-mobile'); if (d !== 'desktop') { dom.viewWrapper.classList.add(`view-${d}`); } }
    function toggleFullscreen() { 
        if (!document.fullscreenElement) { 
            dom.viewWrapper.requestFullscreen().catch(err => alert(`Erro ao entrar em tela cheia: ${err.message}`)); 
        } else { 
            document.exitFullscreen(); 
        } 
    }
    
    // Função para atualizar o ícone do botão tela cheia
    function updateFullscreenIcon() {
        const icon = dom.fullscreenBtn.querySelector('i');
        const title = dom.fullscreenBtn.getAttribute('title');
        
        if (document.fullscreenElement) {
            icon.className = 'fas fa-compress text-lg';
            dom.fullscreenBtn.setAttribute('title', 'Sair da Tela Cheia');
        } else {
            icon.className = 'fas fa-expand text-lg';
            dom.fullscreenBtn.setAttribute('title', 'Tela Cheia');
        }
    }

    // --- SCROLL FUNCTIONS ---
    function toggleScroll() {
        if (state.isScrolling) {
            stopScroll();
        } else {
            startScroll();
        }
    }

    function startScroll() {
        const speedMultiplier = parseFloat(dom.scrollSpeed.value) || 1;
        const manualSpeed = parseFloat(dom.manualSpeed.value) || 1;
        
        // Garantir que os valores não sejam zero
        if (speedMultiplier <= 0 || manualSpeed <= 0) {
            alert('A velocidade deve ser maior que zero.');
            return;
        }
        
        // Verificar se há conteúdo para rolar
        const viewWrapper = dom.viewWrapper;
        const outputArea = dom.outputArea;
        
        // Verificar se o outputArea tem conteúdo suficiente para rolar
        if (outputArea.scrollHeight <= outputArea.clientHeight) {
            alert('Não há conteúdo suficiente para rolar. Gere uma cifra primeiro.');
            return;
        }
        
        let scrollInterval = 100; // Intervalo de 100ms para rolagem mais controlada
        let scrollStep = 0.5 * manualSpeed; // Baseado na velocidade manual


        // Garantir que o passo seja pelo menos 0.01 pixel para permitir rolagem muito lenta
        scrollStep = Math.max(scrollStep, 0.01);
        state.currentScrollStep = scrollStep;
        state.scrollAccumulator = 0; // Acumulador para a rolagem

        state.isScrolling = true;
        state.scrollInterval = setInterval(() => {
            const maxScrollTop = outputArea.scrollHeight - outputArea.clientHeight;
            
            // Adiciona o passo de rolagem ao acumulador
            state.scrollAccumulator += state.currentScrollStep;
            
            // Calcula a quantidade de pixels a rolar
            const scrollAmount = Math.floor(state.scrollAccumulator);

            if (scrollAmount > 0) {
                outputArea.scrollTop += scrollAmount;
                state.scrollAccumulator -= scrollAmount; // Mantém a parte fracionária
            }
            
            // Para quando chegar ao final
            if (outputArea.scrollTop >= maxScrollTop) {
                outputArea.scrollTop = maxScrollTop; // Garante que não ultrapasse o limite
                stopScroll();
            }
        }, scrollInterval);

        dom.scrollToggle.innerHTML = '<i class="fas fa-pause mr-1"></i>Parar Rolagem';
        dom.scrollToggle.classList.remove('bg-blue-600', 'hover:bg-blue-700');
        dom.scrollToggle.classList.add('bg-red-600', 'hover:bg-red-700');
        dom.scrollStatus.textContent = 'Rolando';
    }

    function stopScroll() {
        if (state.scrollInterval) {
            clearInterval(state.scrollInterval);
            state.scrollInterval = null;
        }
        state.isScrolling = false;
        
        dom.scrollToggle.innerHTML = '<i class="fas fa-play mr-1"></i>Iniciar Rolagem';
        dom.scrollToggle.classList.remove('bg-red-600', 'hover:bg-red-700');
        dom.scrollToggle.classList.add('bg-blue-600', 'hover:bg-blue-700');
        dom.scrollStatus.textContent = 'Parado';
    }

    function updateSpeedDisplay() {
        const speed = parseFloat(dom.scrollSpeed.value);
        dom.speedDisplay.textContent = speed + 'x';
        
        // Se estiver rolando, atualiza a velocidade em tempo real
        if (state.isScrolling && state.scrollInterval) {
            updateScrollSpeed();
        }
    }
    
    function updateScrollSpeed() {
        if (!state.isScrolling || !state.scrollInterval) return;
        
        const speedMultiplier = parseFloat(dom.scrollSpeed.value) || 1;
        const manualSpeed = parseFloat(dom.manualSpeed.value) || 1;
        
        let newScrollStep = 0.5 * manualSpeed;
        
        
        // Atualiza o passo de rolagem, garantindo um mínimo de 0.01 pixel
        state.currentScrollStep = Math.max(newScrollStep, 0.01);
    }

    function handleSaveAs() {
        if (!dom.songInput.value.trim()) {
            alert("Por favor, cole uma cifra antes de salvar.");
            return;
        }
        
        // Se é uma música já carregada (tem ID), apenas registra para preenchimento posterior
        if (state.currentSongId) {
            // Música já carregada - será preenchida após abertura do modal
        } else {
            // Música nova - comportamento atual
            
            // Detecta e preenche o tom original
            const currentKey = detectCurrentKey();
            if (currentKey) {
                dom.originalKeyInput.value = currentKey.toUpperCase();
            }
        }
        
        // Sempre define a posição atual do capô no formulário de salvamento
        dom.saveCapoPosition.value = state.capoPosition;
        
        // Limpar formulário antes de abrir o modal
        dom.saveForm.reset();
        
        // Abrir o modal primeiro
        dom.saveModal.showModal();
        
        // Preencher os dados após o modal estar aberto
        setTimeout(() => {
            // Evita preenchimento duplicado
            if (dom.songTitleInput.value && dom.songTitleInput.value.includes('(Cópia)')) {
                return;
            }
            
            // Se é uma música já carregada OU é "Salvar Como", preenche com os dados atuais
            if (state.currentSongId || state.isSaveAs) {
                // Título com "(Cópia)" - sempre usa o título original da música
                if (state.currentSongData && state.currentSongData.title) {
                    // Remove qualquer "(Cópia)" existente e adiciona apenas uma
                    const originalTitle = state.currentSongData.title.replace(/\s*\(Cópia\)\s*$/, '');
                    const newTitle = originalTitle + ' (Cópia)';
                    // Só define se o campo estiver vazio ou não contiver "(Cópia)"
                    if (!dom.songTitleInput.value || !dom.songTitleInput.value.includes('(Cópia)')) {
                        dom.songTitleInput.value = newTitle;
                    }
                } else {
                    // Se não há título, usa o primeiro nome da música
                    const contentLines = dom.songInput.value.split('\n');
                    const firstLine = contentLines[0].trim();
                    if (firstLine && !firstLine.startsWith('[')) {
                        const newTitle = firstLine + ' (Cópia)';
                        if (!dom.songTitleInput.value || !dom.songTitleInput.value.includes('(Cópia)')) {
                            dom.songTitleInput.value = newTitle;
                        }
                    } else {
                        // Se não consegue extrair do conteúdo, usa um título padrão
                        if (!dom.songTitleInput.value || !dom.songTitleInput.value.includes('(Cópia)')) {
                            dom.songTitleInput.value = 'Nova música (Cópia)';
                        }
                    }
                }
                
                // Limpa a flag isSaveAs após o preenchimento
                state.isSaveAs = false;
                
                // Capô atual - sempre usa a posição atual
                dom.saveCapoPosition.value = state.capoPosition;
                
                // Tom original - sempre preserva o tom original da música
                if (state.currentSongData && state.currentSongData.original_key) {
                    // Usa o tom original salvo com a música
                    dom.originalKeyInput.value = state.currentSongData.original_key;
                } else {
                    // Se não há tom original salvo, detecta do conteúdo
                    // Ignora a transposição atual e o capô para determinar o tom original
                    const currentKey = detectCurrentKey();
                    if (currentKey) {
                        dom.originalKeyInput.value = currentKey;
                    }
                }
                
                // Garantir que o tom seja sempre maiúsculo
                if (dom.originalKeyInput.value) {
                    dom.originalKeyInput.value = dom.originalKeyInput.value.toUpperCase();
                }
                
                // Só preencher o tom se não estiver preenchido
                if (!dom.originalKeyInput.value && state.currentSongData && state.currentSongData.original_key) {
                    dom.originalKeyInput.value = state.currentSongData.original_key.toUpperCase();
                }
                
                // Duração e BPM da música original
                if (state.currentSongData) {
                    if (state.currentSongData.duration && !dom.songDuration.value) {
                        dom.songDuration.value = state.currentSongData.duration;
                    }
                    if (state.currentSongData.bpm && !dom.songBpm.value) {
                        dom.songBpm.value = state.currentSongData.bpm;
                    }
                }
            }
        }, 50);
    }

    function resetScroll() {
        if (state.isScrolling) {
            stopScroll();
        }
        dom.outputArea.scrollTop = 0;
    }

    // Toggle password visibility - Versão final (global)
    window.togglePasswordVisibility = function(button) {
        const input = button.parentElement.querySelector('input');
        const icon = button.querySelector('i');
        
        if (!input || !icon) {
            return;
        }
        
        if (input.type === 'password') {
            input.type = 'text';
            icon.className = 'fas fa-eye-slash';
            button.setAttribute('title', 'Ocultar senha');
        } else {
            input.type = 'password';
            icon.className = 'fas fa-eye';
            button.setAttribute('title', 'Mostrar senha');
        }
    }

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // Auth
        dom.loginForm.addEventListener('submit', handleLogin);
        dom.logoutBtn.addEventListener('click', handleLogout);
        
        // Print button
        document.getElementById('print-button').addEventListener('click', () => window.print());
        
        // Event listener para toggle de senha - Versão final
        document.addEventListener('click', function(e) {
            if (e.target.closest('.toggle-password-btn')) {
                const btn = e.target.closest('.toggle-password-btn');
                window.togglePasswordVisibility(btn);
            }
        });
        
        // Inicialização para garantir que todos os inputs de senha estejam corretos
        function initializePasswordInputs() {
            // Inicializar todos os inputs de senha
            const passwordInputs = document.querySelectorAll('input[type="password"]');
            passwordInputs.forEach(input => {
                input.type = 'password';
            });
            
            // Inicializar todos os botões de toggle
            const toggleBtns = document.querySelectorAll('.toggle-password-btn');
            toggleBtns.forEach(btn => {
                btn.setAttribute('title', 'Mostrar senha');
            });
        }
        
        // Executar inicialização
        initializePasswordInputs();
        
        // Re-inicializar quando modais são abertos
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'open') {
                    setTimeout(initializePasswordInputs, 100);
                }
            });
        });
        
        // Observar todos os modais
        const modals = document.querySelectorAll('dialog');
        modals.forEach(modal => {
            observer.observe(modal, { attributes: true });
        });
        
        // Core
        dom.generateButton.addEventListener('click', handleGenerate);
        dom.clearButton.addEventListener('click', handleClearInput);
        dom.transposeUpBtn.addEventListener('click', () => handleTranspose(1));
        dom.transposeDownBtn.addEventListener('click', () => handleTranspose(-1));
        dom.capoPosition.addEventListener('input', handleCapoChange);
        [dom.lyricsSizeSlider, dom.chordsSizeSlider, dom.lyricsColorPicker, dom.chordsColorPicker].forEach(el => el.addEventListener('input', render));
        dom.viewModeToggle.addEventListener('click', handleViewModeToggle);
        dom.columnsToggle.addEventListener('click', handleColumnsToggle);
        document.querySelectorAll('.view-toggle-btn').forEach(b => b.addEventListener('click', e => handleDeviceViewToggle(e.currentTarget.dataset.view)));
        dom.fullscreenBtn.addEventListener('click', toggleFullscreen);
        
        // Scroll functionality
        dom.scrollToggle.addEventListener('click', toggleScroll);
        dom.scrollSpeed.addEventListener('input', updateSpeedDisplay);
        dom.manualSpeed.addEventListener('input', () => {
            dom.scrollSpeed.value = dom.manualSpeed.value;
            updateSpeedDisplay();
        });
        dom.scrollSpeed.addEventListener('input', () => {
            dom.manualSpeed.value = dom.scrollSpeed.value;
            updateSpeedDisplay();
        });
        
        // Event listeners para detectar mudanças no estado de tela cheia
        document.addEventListener('fullscreenchange', updateFullscreenIcon);
        document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
        document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
        document.addEventListener('MSFullscreenChange', updateFullscreenIcon);

        // Songs
        document.querySelectorAll('.cancel-btn').forEach(b => b.addEventListener('click', (e) => e.target.closest('dialog').close()));
        dom.saveButton.addEventListener('click', async () => {
            if (dom.songInput.value.trim()) {
                // Verifica se há uma música carregada com ID
                if (state.currentSongId) {
                    // Para música já carregada, salva diretamente sem abrir modal
                    try {
                        // Aplica as transposições ao conteúdo antes de salvar
                        const originalContent = dom.songInput.value;
                        const transposedContent = applyTranspositionsToContent(originalContent);
                        
                        // Detecta o tom atual baseado no conteúdo modificado
                        const currentKey = detectCurrentKey();
                        const original_key = currentKey || (state.currentSongData?.original_key || '');
                        const duration = state.currentSongData?.duration || '';
                        const bpm = state.currentSongData?.bpm || null;
                        const capo_position = state.capoPosition;
                        
                        // Se não tem currentSongId, precisa recarregar a música para obter o ID
                        if (!state.currentSongId) {
                            // Busca a música pelo título para obter o ID
                            const songs = await fetchApi('/api/songs?filter=my_songs');
                            const song = songs.find(s => s.title === state.currentSongData.title);
                            if (song) {
                                state.currentSongId = song.id;
                            } else {
                                // Se não encontra, cria uma nova música
                                const result = await fetchApi('/api/songs', {
                                    method: 'POST',
                                    body: {
                                        title: state.currentSongData?.title || 'Música sem título',
                                        content,
                                        original_key,
                                        duration,
                                        bpm,
                                        is_public: false,
                                        capo_position
                                    }
                                });
                                alert('Nova música criada com sucesso!');
                                return;
                            }
                        }

                        await fetchApi(`/api/songs/${state.currentSongId}`, { 
                            method: 'PUT', 
                            body: { 
                                title: state.currentSongData?.title || 'Música sem título',
                                content: transposedContent, 
                                original_key, 
                                duration,
                                bpm,
                                is_public: false, 
                                capo_position 
                            } 
                        });
                        alert('Música atualizada com sucesso!');

                           // NÃO recarrega a música - mantém as modificações na tela
                           // await handleLoadSong(state.currentSongId);
                           
                           // Atualiza apenas o state.currentSongData com os novos dados
                           state.currentSongData = {
                               title: state.currentSongData?.title || 'Música sem título',
                               duration: state.currentSongData?.duration || '',
                               bpm: state.currentSongData?.bpm || null,
                               original_key: original_key
                           };
                    } catch (error) {
                        alert('Erro ao atualizar a música: ' + error.message);
                    }
                } else {
                    // Para música nova, abre o modal
                    dom.saveCapoPosition.value = state.capoPosition;
                    const currentKey = detectCurrentKey();
                    if (currentKey) {
                        dom.originalKeyInput.value = currentKey.toUpperCase();
                    }
                    dom.saveModal.showModal(); 
                }
            } else { 
                alert("Por favor, cole uma cifra antes de salvar."); 
            } 
        });
        dom.saveAsButton.addEventListener('click', () => {
            // Preserva os dados da música atual
            const currentSongData = { ...state.currentSongData };
            // Limpa o currentSongId para forçar POST (criar nova música)
            state.currentSongId = null;
            // Restaura os dados da música atual
            state.currentSongData = currentSongData;
            // Adiciona flag para indicar que é "Salvar Como"
            state.isSaveAs = true;
            handleSaveAs();
        });
        dom.saveForm.addEventListener('submit', (event) => {
            handleSaveSong(event);
        });
        dom.openSongsBtn.addEventListener('click', () => { dom.mySongsTab.classList.add('active'); dom.publicSongsTab.classList.remove('active'); loadSavedSongs('my_songs'); dom.songsModal.showModal(); });
        dom.mySongsTab.addEventListener('click', () => { dom.mySongsTab.classList.add('active'); dom.publicSongsTab.classList.remove('active'); loadSavedSongs('my_songs'); });
        dom.publicSongsTab.addEventListener('click', () => { dom.publicSongsTab.classList.add('active'); dom.mySongsTab.classList.remove('active'); loadSavedSongs('public'); });
        dom.modalSongsList.addEventListener('click', handleModalListClick);

        // Users
        dom.manageUsersBtn.addEventListener('click', handleOpenUserManagement);
        if(dom.userManagementModal) dom.modalUsersList.addEventListener('click', handleDeleteUserFromModal);
        if(dom.createUserModal) dom.openCreateUserModalBtn.addEventListener('click', () => { 
            dom.createUserFeedback.classList.add('hidden'); 
            dom.createUserForm.reset(); 
            dom.createUserModal.showModal(); 
            setTimeout(initializePasswordInputs, 100);
        });
        if(dom.createUserForm) dom.createUserForm.addEventListener('submit', handleCreateUser);
        dom.changePasswordBtn.addEventListener('click', () => { 
            dom.changePasswordFeedback.classList.add('hidden'); 
            dom.changePasswordForm.reset(); 
            dom.changePasswordModal.showModal(); 
            setTimeout(initializePasswordInputs, 100);
        });
        dom.changePasswordForm.addEventListener('submit', handleChangePassword);
        
        // Setlists
        if(dom.openSetlistsBtn) dom.openSetlistsBtn.addEventListener('click', handleOpenSetlistsModal);
        if(dom.createSetlistForm) dom.createSetlistForm.addEventListener('submit', handleCreateSetlist);
        if(dom.mySetlistsTab) dom.mySetlistsTab.addEventListener('click', () => { dom.mySetlistsTab.classList.add('active'); dom.publicSetlistsTab.classList.remove('active'); loadSetlists('my_setlists'); });
        if(dom.publicSetlistsTab) dom.publicSetlistsTab.addEventListener('click', () => { dom.publicSetlistsTab.classList.add('active'); dom.mySetlistsTab.classList.remove('active'); loadSetlists('public'); });
        if(dom.modalSetlistsList) dom.modalSetlistsList.addEventListener('click', handleSetlistsListClick);
        if(dom.addToSetlistForm) dom.addToSetlistForm.addEventListener('submit', handleAddToSetlistSubmit);
        if(dom.addSongsToSetlistModal) {
            const cancelBtns = dom.addSongsToSetlistModal.querySelectorAll('.cancel-btn');
            cancelBtns.forEach(btn => btn.addEventListener('click', () => dom.addSongsToSetlistModal.close()));
        }

        // Password Visibility Toggle já está configurado acima
        // Removido event listener duplicado para evitar conflitos

        // Cifra padrão
        if (dom.songInput.value.trim() === "") { dom.songInput.value = `[Intro]\nG D Em C\n\n[Verso 1]\n   G              D\nVim para adorar-te\n   Em             C\nVim para prostrar-me\nG              D           C\nVim para dizer que és meu Deus`; }
        
        // Inicializar velocidade de rolagem
        updateSpeedDisplay();
        
        checkAuthStatus();
    });
    </script>
</body>
</html>
